//runs super fast once the node server is up
//button press needs testing - rpio library throwing errors
//so that has highest priority now
//other than that we're fine, readline for testing right now



//migrating from applest-atem to atem-connection

const { Atem } = require('atem-connection'); //new library
const myAtem = new Atem();
var rpio = require('rpio');
//var ATEM = require('applest-atem'); //deprecated
const readline = require('readline');
const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});


const buzzer = require('./buzzer.js');

let buzzers = [];

let dskonair = false;


rpio.init({
	gpiomem: false,
	mapping: 'physical',
	mock: undefined,
	close_on_exit: true,
});


myAtem.on('info', console.log);
myAtem.on('error', console.error);

myAtem.connect('192.168.10.240');

//console.log('alive');

//buzzers[0] = new buzzer(1, 3, 10, 32, 1);

//console.log('still alive');

//buzzers[0].setuppins();
//buzzers[0].listen();

//console.log('probably no longer alive');

//so far i'm hardcoding the downstream key mask on connection - need to wire this to switch logic
//via rpio pins
myAtem.on('connected', () => {
	let dummy = {rate: 3};
	myAtem.setMixTransitionSettings(dummy);
	myAtem.setDownstreamKeyFillSource(1,0);
	myAtem.setDownstreamKeyCutSource(1,0);
	myAtem.setDownstreamKeyGeneralProperties({
			preMultiply: false,
			clip: 750,
			gain: 900,
			invert: true 
			});
	myAtem.changeProgramInput(3).then(() => {
		console.log('Program input set');
	});
	console.log(myAtem.state);
})

/*
myAtem.on('stateChanged', (state, pathToChange) => {
	console.log("STATE \n");
	console.log(state);
	console.log("VIDEO \n");
	console.log(state.video);
	console.log("MIXEFFECTS \n");
	console.log(state.video.mixEffects);
//	console.log("UPSTREAMKEYERS \n");
//	console.log(state.video.mixEffects.upstreamKeyers[0]); //having problems accessing upstreamkeystate
								//why do these libraries insist on using the weirdest json syntax ever
	console.log("DOWNSTREAMKEYERS \N");
	console.log(state.video.downstreamKeyers);
});
*/



recurse();


//global variable to store active channel
let activechannel = 1; //probably should initialize this

//var atem = new ATEM();

const randomInt = () => Math.floor((Math.random() * 4) + 1);

//atem.connect('192.168.10.240');

/*
atem.on('connect', function() {
	doStuff();
});

*/

//the following function floods the screen because apparently the atem sends state change messages A LOT
//therefore i'll give it a sanity debug flipflop variable thingy
//which gets set back to active after i've changed the state

var sanity = 1

//need to reimplement tally switching depending on state

myAtem.on('stateChanged', (state, pathToChange) => {
	if (sanity === 1) {
	//console.log(state.video.mixEffects[0]); //catch the atem state.
	console.log(state.video.downstreamKeyers[0]);
	sanity = 0; //lets not flood the screen please.
	}
	/*if (state.video.ME[0].programInput != activechannel){ //WHY IS THIS AN ARRAY WITH ONLY ONE OBJECT INSIDE
	console.log(state.video.ME[0].programInput); //does this react when i set the channel by hand? yes
	activechannel = state.video.ME[0].programInput;
	pulseLED(state.video.ME[0].programInput - 1);
	sanity = 0;
	}*/
});


function recurse() {

	rl.question("what ?", function(num){
	if(num){
	doNum(num);
	}
	recurse();
	});

}
/*

//this one for no user input
function doStuff() {
	atem.changeProgramInput(randomInt());
	atem.changePreviewInput(randomInt());
	atem.cutTransition();
	//	atem.changeProgramInput(3,1);
}
*/
//this one for user input
function doNum(num) {

	if(num > 0 && num < 5){
		//myAtem.changeProgramInput(num);
		myAtem.changePreviewInput(num);
		//myAtem.cut();
		myAtem.autoTransition();
		//myAtem.cutTransition();
		//	atem.changeProgramInput(3,1); //these numbers are probably wrong <-- definetly wrong
		pulseLED(num-1); //zero index so we subtract 1
		sanity = 1; //for debugging purposes - reenables state printing to console
		activechannel = num; // store our active channel in global variable - to double check with state later on
	} else if (num == 8) {
	dskonair = !dskonair;
	myAtem.setDownstreamKeyOnAir(dskonair);
	} else console.log('bad number, broski');
}
//buzzer pins
rpio.open(3, rpio.INPUT, rpio.PULL_UP);
rpio.open(5, rpio.INPUT, rpio.PULL_UP);
rpio.open(7, rpio.INPUT, rpio.PULL_UP);
rpio.open(13, rpio.INPUT, rpio.PULL_UP);


function pollcb(pin)
{
	rpio.msleep(30);
	if (rpio.read(pin))
		return;
	console.log('Button pressed on pin P%d', pin);
	if(pin == 3) doNum(1);
	if(pin == 5) doNum(2);
	if(pin == 7) doNum(3);
	if(pin == 13) doNum(4);

}

rpio.poll(3, pollcb, rpio.POLL_LOW);
rpio.poll(5, pollcb, rpio.POLL_LOW);
rpio.poll(7, pollcb, rpio.POLL_LOW);
rpio.poll(13, pollcb, rpio.POLL_LOW);


//switch pins
rpio.open(10, rpio.INPUT, rpio.PULL_UP);
rpio.open(11, rpio.INPUT, rpio.PULL_UP);
rpio.open(16, rpio.INPUT, rpio.PULL_UP);
rpio.open(15, rpio.INPUT, rpio.PULL_UP);


function polltoggle(pin)
{
	rpio.msleep(30);
	if (rpio.read(pin))
		return;
	console.log('toggle ' + pin + ' switched on');

}

rpio.poll(3, polltoggle, rpio.POLL_LOW);
rpio.poll(5, polltoggle, rpio.POLL_LOW);
rpio.poll(7, polltoggle, rpio.POLL_LOW);
rpio.poll(13, polltoggle, rpio.POLL_LOW);



function pulseLED(index){

	var pinmap = [12,32,33,35];

	if(pinmap[index]){		//zero index fuckery
		pin = pinmap[index];
	} else { return;}

	rpio.open(pin, rpio.OUTPUT);
	rpio.write(pin, rpio.HIGH);
	
	for(let i = 0; i<4; i++){
		if(pinmap[i] != pin){
		rpio.write(pinmap[i], rpio.LOW);
		}
	}
}



//PWM section - note that PWM requires root privileges 
//so as a first step we should write a quick test routine
//to see whether the service has those privileges
//note: only pins 12,32,33,35 are PWM enabled
//and gpiomem:false needs to be set (somewhere)
//SUCCESS!!! we have root privileges with our service

/*
rpio.open(12, rpio.PWM); //use pin 12 for pwm 
rpio.open(32, rpio.PWM); // etc... 
rpio.open(33, rpio.PWM);
rpio.open(35, rpio.PWM);
*/
/*
rpio.pwmSetClockDivider(8); 
rpio.pwmSetRange(12,1024);
*/
//encapsulating the following into a function

//pray that it works i guess....
//we'll call this function elsewhere with a lookup array to map the pin numbers


/*
function pulseLED(channelnumber)
{

var pinmap = [12,32,33,35];

if(pinmap[channelnumber]){		//zero index fuckery
	pin = pinmap[channelnumber];
} else { return;}



rpio.open(pin, rpio.OUTPUT); //let's try opening the pin only when we call the function
//rpio.pwmSetClockDivider(8); /* afaik these are global */
//rpio.pwmSetRange(12,1024);

/*
var times = 1;
var interval = 5; //milliseconds
var direction = 1;
var data = 0;
var range = 1024;
var max = 128;
var pulse = setInterval(function() {
	rpio.pwmSetData(pin,data);
	if (data === 0) {
		direction = 1;
		if (times-- === 0) {
			clearInterval(pulse);
			rpio.open(pin,rpio.INPUT);
			return;
		}
	} else if (data === max) {
		direction = -1;
	}
	data += direction;
}, interval, data, direction, times);
}
*/

/*
 *atem.on('stateChanged', function(err, state) {
 *  console.log(state); // catch the ATEM state.
 *});
 */



